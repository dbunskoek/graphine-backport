#! /usr/bin/env python

"""
base.py

Written by Geremy Condra

Many thanks to Patrick Laban and Robbie Clemons

Licensed under the GNU GPLv3

Released 25 Mar 2009

This module contains the base GraphElement, Node, Edge,
and Graph implementations for Graphine, an easy-to-use,
easy-to-extend Graph library.

Graphs generated using this representation can have
directed, undirected, and parallel edges.

Interface summary
=================

To create a new Graph:

	>>> from graph.base import Graph
	>>> g = Graph()

Adding elements to a Graph
--------------------------

In Graphine, each element has a unique hashable name and
data attributes. If you do not provide a name at
instantiation time, one will be autogenerated, but it is
strongly recommended that you provide one, since element
comparisons (and therefore graph comparisons) are done by
name.

To add a node:

	>>> node_1 = g.add_node()
	>>> node_1
	Node(name=3082215852)

To add a named node:

	>>> node_2 = g.add_node("bob")
	>>> node_2
	Node(name=bob)

To add a node with data attributes:

	>>> node_3 = g.add_node("dan", weight=5)
	>>> node_3
	Node(name=dan, weight=5)

Since Edges connect nodes, it makes sense that instantiating
an edge will require exactly two nodes as arguments. These
can be specified either by name or by element reference.

To add an edge:

	>>> edge_1 = g.add_edge(node_1, node_2)
	>>> edge_1
	Edge(name=(3082215852, 'bob'))

To add a named edge:

	>>> edge_2 = g.add_edge(node_2, node_3, "2->3")
	>>> edge_2
	Edge(name=2->3)

To add an edge by node name:

	>>> edge_3 = g.add_edge("bob", "dan", "bob->dan")
	>>> edge_3
	Edge(name=bob->dan)

Notice that edges can have data attributes as well:

	>>> edge_4 = g.add_edge("dan", "dan", "dan->dan", weight=5)
	>>> edge_4
	Edge(name=dan->dan, weight=5)

You can access these attributes using normal attribute notation:

	>>> edge_4.weight
	5
	>>> edge_4.weight = 7
	>>> edge_4.weight
	7

We can also add attributes on the fly:

	>>> edge_4.color = "blue"
	>>> edge_4
	Edge(name=dan->dan, weight=7, color=blue)

Edges also permit a keyword argument is_directed, which indicates
whether that edge should be directed or undirected. Its default
value is True, meaning that the edge will be directed from the
first node provided to the second node provided.

	>>> edge_5 = g.add_edge(node_1, node_2, "1->2", is_directed=False)
	>>> edge_5
	Edge(name=1->2)

In the next section, you will learn how to use the properties
of Nodes and Edges to verify this.

In addition to adding nodes and edges, you can remove them.
This can also be done either by name or by element reference.

To remove nodes:

	>>> g.remove_node(node_1)
	Node(name=3082215852)

To remove nodes by name:

	>>> g.remove_node("bob")
	Node(name=bob)

And edges:

	>>> g.remove_edge(edge_4)

Note that removing one or more of an Edge's endpoints will
remove that edge as well, so the following will raise KeyError:

	>>> g.remove_edge(edge_4)

Navigating Graphs
-----------------

In addition to storing your data, Nodes and Edges have
a few other special properties by default.

For Nodes, these properties are "incoming" and "outgoing",
and they contain the incoming and outgoing edges attached
to that node. The "bidirectional" property is also there
in case you only want the edges which go both ways. An
additional property "edges" contains all of these elements.

For Edges, these properties are (again, by default)
"start" and "end". Because edges can be bidirectional,
they also have an "is_directed" property, and provide
the convenience function "other_end", which takes a
node and, if possible, returns the opposite endpoint
incident to that edge.

Let's say we have constructed the following graph:

	>>> G = Graph()
	>>> G.add_node("A")
	Node(name=A)
	>>> G.add_node("B")
	Node(name=B)
	>>> G.add_node("C")
	Node(name=C)
	>>> G.add_edge("A", "B", "AB")
	Edge(name=AB)
	>>> G.add_edge("B", "C", "BC")
	Edge(name=BC)
	>>> G.add_edge("C", "A", "CA", is_directed=False)
	Edge(name=CA)

Notice that we haven't stored any references to our Nodes
or Edges. We can do this because the graph automatically
converts between names and elements- which is why it is so
important that names be unique within a graph.

We can get an element from that graph by name by using the
standard getitem syntax:

	>>> n1 = G["A"]
	>>> n1
	Node(name=A)
	>>> e1 = G["AB"]
	>>> e1
	Edge(name=AB)

It should be noted that this also works for elements, and
can be a quick test to get an element in the given graph
equivalent to one from another graph:

	>>> G["A"] is n1
	True

Of course, now that we have a Node and Edge we can begin
to explore the graph from those points.

To get all the outgoing edges of a particular node:

	>>> n1.outgoing
	[Edge(name=AB), Edge(name=CA)]

And to get the incoming edges:

	>>> n1.incoming
	[Edge(name=CA)]

The same sorts of things work for the properties
"bidirectional" and "edges".

	>>> n1.bidirectional
	[Edge(name=CA)]
	>>> n1.edges
	[Edge(name=CA), Edge(name=AB)]

You can also directly get all the nodes adjacent to a
given node:

	>>> n1.get_adjacent()
	[Node(name=B), Node(name=C)]

From this, we can verify the following:

	>>> len(n1.get_adjacent())
	2
	>>> n1.degree
	2

You can combine this with Edges' "start" and "end" properties
to navigate your graph, if you know how your data is related
structurally. For example, to get the oldest outgoing edge attached
to the oldest node attached to n1, I could do the following:

	>>> interesting_node = n1.outgoing[0].end.outgoing[0]

In addition to these properties, Edges provide the "other_end"
function, which takes a node and, if possible, returns the edge's
other end. If it cannot follow the edge to a point opposite the
given node- for instance, because the edge is directed the other
way- it raises AttributeError.

	>>> endpoint = e1.other_end("A")
	>>> endpoint
	Node(name=B)
	>>> e1.other_end("B")
	...
	AttributeError: Edge(name=AB) has no endpoint opposite to B

You will frequently see "other_end" used in situations where it is
possible that the given edge could be either directed or undirected,
or where the orientation of a directed edge is unknown.

Of course, there are scenarios in which you don't know how to
navigate your graph, or need to find a starting point that isn't
easily determined based on a given element's properties. For that,
Graph supports Node and Edge iteration for the simple cases, and
traversals and walks for more complex behavior.

To iterate over all the nodes in a graph:

	>>> for node in G.nodes:
	...	print(node)
	...
	Node(name=C)
	Node(name=A)
	Node(name=B)

Notice that these are in no particular order- Graphs do not store
elements in a sequence, and so you should not count on them being
presented in the same order on two consecutive passes.

To do the same for edges:

	>>> for edge in G.edges:
	... 	print(edge)
	...
	Edge(name=BC)
	Edge(name=CA)
	Edge(name=AB)

If you only want certain nodes, the search functions are provided
for convenience:

	>>> for node in G.search_nodes(name="A"):
	... 	print(node)
	...
	Node(name=A)

And for edges:

	>>> for edge in G.search_edges(name="CA", is_directed=False):
	... 	print(edge)
	...
	Edge(name=CA)

In addition to the datawise and unordered views of graphs,
several methods for ordering based on structural properties
are provided. The most important of these are traversals
and walks.

Three traversals are provided by default- heuristic, depth
first, and breadth first. They are all guaranteed to only
visit a given node once, and visit nodes in a different order
based on how they are related structurally.

To do a depth first traversal:

	>>> for node in g.depth_first_traversal(n1):
	>>> 	print(node)
	Node(name=A)
	Node(name=B)
	Node(name=C)

Note that CA is an outgoing edge of n1, but will come
after the AB edge on account of being bidirectional, and
so this ordering is guaranteed.

Breadth first traversals are similar in usage, simply
substituting "depth_first_traversal" for "breadth_first_traversal".

Heuristic traversals are similar to both breadth first and depth
first, but require an additional callable argument. This callable
will be passed a list of unvisited nodes and should select and
remove exactly one of them to return.

For example, to navigate a graph by visiting the most
popular (ie, most incoming edges) nodes first, I could
write a getter function as follows:

	>>> def get_popularity(node):
	... 	return len(node.incoming)
	...

A selector function:

	>>> def get_most_popular(nodes):
	... 	nodes.sort(key=get_popularity)
	...	return nodes.pop()
	...

And traverse the graph:

	>>> for node in G.heuristic_traversal("A", get_most_popular):
	>>> 	print(node)
	Node(name=A)
	Node(name=C)
	Node(name=B)

Note, again, that names and elements can be used interchangably.

In contrast to the traversals, walks can visit a node or edge
more than once. They are the most flexible structural technique
provided, but also do the least hand-holding of any of the
mechanisms provided, so check your assumptions carefully before
using an unlimited walk on a graph whose properties you are
unsure of.

The walks are implemented as wrapped generators, with each step
yielding a set of nodes (for walk_nodes) or edges (for walk_edges)
that are potentially "next" in terms of adjacency. The application
should select one of those and use send() to send it back. As an
example, we can implement an endless B-C-A-B loop as follows:

	>>> w = G.walk_nodes("A")
	>>> for adjacent in w:
	... 	w.send(adjacent[0])

The usage for walk_edges is identical, excepting that it accepts
an edge and that "adjacent" from the example would be list of
edges rather than nodes.

Finally, there is heuristic_walk, which is similar to the
heuristic_traversal in that it accepts a callable heuristic
argument and similar to the other walks in that it does similarly
little in the way of bookkeeping. To perform the walking version
of the heuristic traversal provided earlier, we could use the
same heuristic and simply do the following:

	>>> for node in heuristic_walk("A", get_most_popular):
	... 	print(node)

Inspecting Graphs
-----------------

The base Graph class provides several tools for finding potentially
interesting pieces of information about your graphs.

The most straightforward of these are .order and .size, which
return the number of nodes in the graph and the number of edges in
the graph, respectively.

In addition, it has facilities to find out about the connectivity
of the given graph.

.get_connected_components() returns a list of sets of connected
verticies.

.get_strongly_connected() returns a list of sets of strongly
connected components.

.get_shortest_paths(source) returns a mapping of nodes to
a (length, [path]) pair, where path is a sequence of edges
connecting the given endpoints.

Binary Graph Operations
-----------------------

Four basic operations are provided for the comparison
of graphs:

	1. union (|), which creates a new graph containing all
	   the nodes and edges in either of its parents,

	2. intersection (&), which creates a new graph containing
	   all the nodes and edges in both of its parents,

	3. difference (-), which creates a new graph containing
	   all the nodes and edges in the first parent but
	   not in the second.

	4. merge (+), which creates a new graph with all the
	   data-unique nodes from both parent graphs plus all
	   their structurally and data unique edges.

For more information on the usage of these functions, consult their
individual docstrings.
"""

# Copyright (C) 2009 Geremy Condra
#
# This file is part of Graphine.
#
# Graphine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Graphine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Graphine.  If not, see <http://www.gnu.org/licenses/>.


from collections import deque, namedtuple, defaultdict
import heapq
import copy
from itertools import chain, count

class GraphElement:
	"""Base class for Nodes and Edges.

	A GraphElement.data property is provided to give easier
	access to all of the element's non-structural member
	variables. It returns a dictionary.

	In addition, a GraphElement.name property is provided
	to allow property access to the object's name.

	It also provides an __repr__ member function to make
	easier work of analyzing your graphs.

	Graph elements compare based on names.
	"""

	def __repr__(self):
		"""Pretty prints this element."""
		classname = type(self).__name__
		name = "name=%s, " % str(self.name)
		attrs = name + ''.join(("%s=%s, " % (k, v) for k, v in self.data.items()))
		attrs = attrs[:-2]
		return "%s(%s)" % (classname, attrs)

	def __lt__(self, other):
		"""Arbitrary comparison for sorting."""
		return id(self) < id(other)

	def __hash__(self):
		"""Returns the hash of this object's name."""
		return hash(self._name)

	def __eq__(self, other):
		"""Compares the two elements based on name."""
		if type(self) != type(other): return False
		return self.name == other.name

	def __ne__(self, other):
		"""Compares the two elements based on name."""
		return not self == other

	@property
	def name(self):
		"""Returns this object's name."""
		return self._name

	@property
	def data(self):
		"""Returns a dictionary representing the data values of this element.

		Note that elements which are marked private- ie, start with a single
		underscore- will not appear in this dictionary.
		"""
		d = {}
		for k, v in self.__dict__.items():
			if not k.startswith("_"):
				d[k] = v
		return d


class Node(GraphElement):
	"""Base node representation.

	Nodes have seven properties:

	- incoming, which is a list of all edges coming into this node
	- outgoing, which is a list of all edges going away from this node
	- bidirectional, which is a list of all bidirectional edges incident
	  to this node
	- edges, which is a list of all edges with this node as an endpoint
	- degree, which is the number of edges incident to this node
	- data, which is a dictionary of all non-private (ie, user-defined)
	  attributes of this node
	- and name, which is a unique value optionally passed in
	  at instantiation time, and used for hashing comparisons.
	"""

	def __init__(self, name, **kwargs):
		"""Initializes the Node object.

		Accepts an mandatory name argument and a variable number of kwargs.

		The kwargs are mapped into attributes.

		Usage:

			>>> n = Node("bob", weight=5)
			>>> n.name
			bob
			>>> n.weight
			5
		"""

		self._name = name
		self._incoming = []
		self._outgoing = []
		self._bidirectional = []
		for k, v in kwargs.items():
			setattr(self, k, v)

	def get_adjacent(self, outgoing=True, incoming=False):
		"""Returns a list of all adjacent nodes.

		The optional arguments outgoing and incoming indicate
		whether to include those edge sets in the search field.
		Their defaults are True and False, accordingly.

		If provided, outgoing and incoming should be booleans.
		"""
		adjacent = []
		seen = set()
		if outgoing:
			for edge in self._outgoing:
				if edge.end not in seen:
					adjacent.append(edge.end)
					seen.add(edge.end)
		if incoming:
			for edge in self._incoming:
				if edge.start not in seen:
					adjacent.append(edge.start)
					seen.add(edge.start)
		if outgoing or incoming:
			for edge in self._bidirectional:
				if edge.other_end(self) not in seen:
					adjacent.append(edge.other_end(self))
					seen.add(edge.other_end(self))
		return adjacent

	@property
	def incoming(self):
		"""Returns a list of all the incoming edges for this node.

		Note that the list returned is a copy, so modifying it doesn't
		impact the structure of the graph.
		"""
		return copy.copy(self._incoming + self._bidirectional)

	@property
	def outgoing(self):
		"""Returns a list of all the outgoing edges for this node.

		Note that the list returned is a copy, so modifying it doesn't
		impact the structure of the graph.
		"""
		return copy.copy(self._outgoing + self._bidirectional)

	@property
	def bidirectional(self):
		"""Returns a list of all bidirectional edges for this node.

		Note that the list returned is a copy, so modifying it doesn't
		impact the structure of the graph.
		"""
		return copy.copy(self._bidirectional)

	@property
	def edges(self):
		"""Returns a list of all edges for this node.

		Note that the list returned is a copy, so modifying it doesn't
		impact the structure of the graph.
		"""
		# we have to ensure that all these elements are unique, since loops can be
		# both incoming and outgoing.
		return copy.copy(list(set(self._incoming + self._outgoing + self._bidirectional)))

	@property
	def degree(self):
		"""Returns the degree of this Node, ie, the number of edges."""
		return len(self.edges)


class Edge(GraphElement):
	"""Base edge representation.

	Edges have five properties.
	- start, which is the starting node
	- end, which is the end node
	- is_directed, which indicates if the edge is
	  directed or undirected
	- name, which is a unique, non-None value optionally
	  passed in at instantiation time, and used for hashing
	  comparisons
	- data, which is a dictionary of all non-private
	  (ie, user-defined) attributes of this node
	"""

	def __init__(self, start, end, name=None, is_directed=True, **kwargs):
		"""Initializes the Edge.

		Accepts start and end arguments, which should be Node objects,
		an optional name (one will be autogenerated based on object id
		if not provided), the is_directed flag, which controls whether
		this is a directed or undirected edge, and a variable number of
		kwargs, which will be mapped into attributes.

		Usage:
			>>> e = Edge(Node("A"), Node("B"), "AB", is_directed=False, weight=5)
			>>> e.name
			"AB"
			>>> e.start
			Node(name=A)
			>>> e.end
			Node(name=B)
			>>> e.weight
			5
		"""
		if name is not None: self._name = name
		elif is_directed: self._name = (start.name, end.name)
		else: self._name = frozenset((start.name, end.name))
		self._start = start
		self._end = end
		self._directed = is_directed
		for k, v in kwargs.items():
			setattr(self, k, v)

	def __getitem__(self, index):
		"""Returns the endpoint corresponding to the given index.

		If the index > 1, this raises IndexError.

		For this reason, this is mostly intended to be used for tuple-style unpacking.

		Usage:
			>>> e = Edge(Node("A"), Node("B"), "AB")
			>>> a, b = e
			>>> a
			Node(name=A)
			>>> b
			Node(name=B)
		"""
		if not index: return self.start
		elif index is 1: return self.end
		raise IndexError("The index %s does not correspond to an endpoint of %s" % (index, self))

	def other_end(self, starting_point):
		"""Returns the other end of the edge from the given point.

		If the point given is not an endpoint on this edge or the
		endpoint on a directed edge, this raises AttributeError.
		"""
		if starting_point is self.start or starting_point is self.start.name:
			return self.end
		elif not self.is_directed:
			if starting_point is self.end or starting_point is self.end.name:
				return self.start
		raise AttributeError("%s has no endpoint opposite to %s" % (self, starting_point))

	@property
	def start(self):
		"""Returns the starting point for this edge."""
		return self._start

	@property
	def end(self):
		"""Returns the ending point for this edge."""
		return self._end

	@property
	def is_directed(self):
		"""Returns whether this is a directed edge or not."""
		return self._directed


class Graph:

	"""A basic graph class, and base for all Graph mixins.

	In graph theoretic terms, this represents a bridge multigraph.
	This means that it supports both directed and undirected edges,
	loops, and parallel edges.

	Note that element names must be unique within this graph; non
	unique element names between graphs are not only allowable, but
	encouraged if you wish for those elements to compare equally
	between graphs.

	Because of its generality, it is suitable as a general-purpose
	Graph representation.
	"""

	Node = Node
	Edge = Edge

	def __init__(self, nodes=set(), edges=set()):
		"""Base initializer for Graphs.

		Accepts two keyword arguments: nodes and edges.

		Nodes can be either an iterable whose items are valid node
		names or a mapping of node names to a dictionary of attributes.
		Intuitively, this is equivalent to:

		>>> for n in nodes:
		... 	g.add_node(n)

		or:

		>>> for n in nodes:
		... 	g.add_node(n, **nodes[n])

		The same logic applies for the edges argument, for example:

		>>> for e in edges:
		... 	g.add_edge(*e)

		or:

		>>> for e in edges:
		... 	g.add_edge(*e, **edges[e])

		Usage:
			>>> g = Graph()
			>>> g = Graph(nodes={'a', 'b', 'c'})
			>>> 'a' in g
			True
			>>> g = Graph(nodes={'a', 'b'}, edges={('a','b')})
			>>> ('a', 'b') in g
			True
			>>> ('b', 'a') in g
			False
			>>> g = Graph(nodes={'a', 'b'}, edges={('a', 'b', 'ab', False)})
			>>> 'ab' in g
			True
			>>> g['ab'].is_directed
			False
			>>> g = Graph(nodes={'a':{'spotted':True}, 'b':{'spotted':False}}, edges=[('a', 'b')])

		"""
		# initialize the basic elements of the graph
		self._nodes = {}
		self._edges = {}
		# the counter is a thread-safe way to track default names
		self._counter = count()
		# add the nodes and edges specified by kwargs
		for node in nodes:
			try: self.add_node(node, **nodes[node])
			except TypeError: self.add_node(node)
		for edge in edges:
			try: self.add_edge(*edge, **edges[edge])
			except TypeError: self.add_edge(*edge)

	#################################################################
	#			Operators				#
	#################################################################

	def __contains__(self, element):
		"""Returns True if the element is a member of the graph.

		Usage:
			>>> g = Graph()
			>>> n = g.add_node()
			>>> n in g
			True
		"""
		# if its a node
		if isinstance(element, self.Node):
			return element.name in self._nodes
		# if its an edge
		elif isinstance(element, self.Edge):
			return element.name in self._edges
		# if its a name
		else:
			return element in self._nodes or element in self._edges

	def __getitem__(self, name):
		"""Returns the element corresponding to the given name or the
		given element's name.

		Raises KeyError if it is not found.
		"""
		name = self.get_name(name)
		# get the element if it exists
		element = self._nodes.get(name, False)
		element = element or self._edges.get(name, False)
		if not element: raise KeyError("%s not in %s" % (name, self))
		return element

	def __and__(self, other):
		"""Maps the & operator to the intersection operation."""
		return self.intersection(other)

	def __or__(self, other):
		"""Maps the | operator to the union operation."""
		return self.union(other)

	def __sub__(self, other):
		"""Maps the - operator to the difference operation."""
		return self.difference(other)

	def __eq__(self, other):
		"""Compares based on node and edge names."""
		if set(self._nodes.keys()) == set(other._nodes.keys()):
			if set(self._edges.keys()) == set(other._edges.keys()):
				return True
		return False

	def __lt__(self, other):
		"""Compares based on containment.

		This returns True if this graph is contained in other.
		"""
		return other.contains(self) and not self.contains(other)

	def __gt__(self, other):
		"""Compares baed on containment.

		This returns True if it contains other, False otherwise.
		"""
		return self.contains(other) and not other.contains(self)

	#################################################################
	#			Properties				#
	#################################################################

	@property
	def nodes(self):
		"""Returns an iterator over all the nodes in the graph."""
		return self._nodes.values()

	@property
	def edges(self):
		"""Returns an iterator over all the edges in the graph."""
		return self._edges.values()

	#################################################################
	#		     Convenience Functions			#
	#################################################################

	def get_element(self, item):
		"""Takes an element or a name and returns an element.

		If no element corresponds to the given name, raises
		KeyError.
		"""
		if isinstance(item, GraphElement):
			element = self._edges.get(item.name, False)
			element = element or self._nodes.get(item.name, False)
			if not element: raise KeyError("%s not in %s" % (item, self))
			return element
		else:
			element = self._edges.get(item, False)
			element = element or self._nodes.get(item, False)
			if not element: raise KeyError("%s not in %s" % (item, self))
			return element

	def get_name(self, item):
		"""Takes an element or a name and returns a name.

		If no element corresponds to the given name, raises
		KeyError
		"""
		if isinstance(item, GraphElement):
			item = item.name
		else:
			item = item
		if item in self._nodes: return item
		if item in self._edges: return item
		raise KeyError("%s not in %s" % (item, self))

	#################################################################
	#		    Graph Construction Tools			#
	#################################################################

	def add_node(self, name=None, **kwargs):
		"""Adds a node with no edges to the current graph.

		The name argument, if given, should be hashable and
		unique in this graph.

		Usage:
			>>> g = Graph()
			>>> g.add_node("bob", weight=5)
			Node(name=bob, weight=5)
		"""
		# create the new node
		if name is None: name = next(self._counter)
		node = self.Node(name, **kwargs)
		# remove any otherwise identical nodes
		try: self.remove_node(node)
		except: pass
		# add the node to the backing data store
		self._nodes[node._name] = node
		return node

	def add_edge(self, start, end, name=None, is_directed=True, **kwargs):
		"""Adds an edge to the current graph.

		The start and end arguments can be either nodes or node names.
		If they don't exist in the current graph, they will be created.

		The name argument, if given, should be hashable and unique
		in this graph.

		The optional argument "is_directed" specifies whether
		the given edge should be directed or undirected.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node(), g.add_node()
			>>> g.add_edge(n1, n2, weight=5)
			Edge(weight=5)
		"""
		# get the start and end points, and create them if they don't exist
		try: start = self.get_element(start)
		except: start = self.add_node(start)
		try: end = self.get_element(end)
		except: end = self.add_node(end)
		# build the edge
		edge = self.Edge(start, end, name, is_directed=is_directed, **kwargs)
		# remove any otherwise identical edges
		try: self.remove_edge(edge)
		except: pass
		# and add the edge to the backing data store
		self._edges[edge.name] = edge
		# now take care of adjacency tracking
		if is_directed:
			start._outgoing.append(edge)
			end._incoming.append(edge)
		else:
			start._bidirectional.append(edge)
			# stops the edge from being added twice if it is an undirected
			# loop
			if start is not end:
				end._bidirectional.append(edge)
		return edge

	def remove_node(self, node):
		"""Removes a node from the graph.

		Usage:
			>>> g = Graph()
			>>> n = g.add_node()
			>>> g.remove_node(n)
			>>> n in g
			False
		"""
		# get the actual node if a name is passed in
		node = self.get_element(node)
		# remove it from adjacency tracking
		for edge in node.edges:
			self.remove_edge(edge)
		# remove it from storage
		n = self._nodes.pop(node.name)
		return n

	def remove_edge(self, edge):
		"""Removes an edge from the graph.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node(), g.add_node()
			>>> e = g.add_edge(n1, n2)
			>>> g.remove_edge(e)
			>>> e in g
			False
		"""
		# get the actual edge if a name is passed
		edge = self.get_element(edge)
		# remove it from adjacency tracking
		start = edge.start
		end = edge.end
		if edge.is_directed:
			start._outgoing.remove(edge)
			end._incoming.remove(edge)
		else:
			start._bidirectional.remove(edge)
			# fix the undirected loop problem
			if start is not end:
				end._bidirectional.remove(edge)
		# remove it from storage
		e = self._edges.pop(edge.name)
		return e

	#########################################################################
	#			Graph Inspection Tools  			#
	#########################################################################

	def search_nodes(self, **kwargs):
		""" Convenience function to get nodes based on some properties.

		Usage:
			>>> g = Graph()
			>>> n1 = g.add_node("bob")
			>>> n2 = g.add_node("bill")
			>>> for node in g.search_nodes(name="bob"):
			... 	print(node)
			Node(name="bob")
		"""
		desired_properties = set(kwargs.items())
		for node in self.nodes:
			properties = set(node.data.items())
			if "name" in kwargs:
				properties.add(("name", node.name))
			if properties.issuperset(desired_properties):
				yield node

	def search_edges(self, **kwargs):
		"""Convenience function to get edges based on some properties.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node(), g.add_node()
			>>> e1 = g.add_edge(n1, n2, weight=4)
			>>> e2 = g.add_edge(n1, n2, "n1->n2", weight=5)
			>>> for edge in g.search_edges(weight=5):
			... 	print(edge)
			Edge(name=n1->n2, weight=5)
		"""
		if "start" in kwargs:
			kwargs["start"] = self.get_element(kwargs["start"])
		if "end" in kwargs:
			kwargs["end"] = self.get_element(kwargs["end"])
		desired_properties = set(kwargs.items())
		for edge in self.edges:
			attrs = set(edge.data.items())
			if "name" in kwargs:
				attrs.add(("name", edge.name))
			if "start" in kwargs:
				attrs.add(("start", edge.start))
			if "end" in kwargs:
				attrs.add(("end", edge.end))
			if "is_directed" in kwargs:
				attrs.add(("is_directed", edge.is_directed))
			if attrs.issuperset(desired_properties):
				yield edge

	def get_common_edges(self, n1, n2):
		"""Gets the common edges between the two nodes.

		Usage:
			>>> g = Graph()
			>>> n1 = g.add_node()
			>>> n2 = g.add_node()
			>>> e = g.add_edge(n1, n2, "fluffy")
			>>> g.get_common_edges(n1, n2)
			{Edge(name="Fluffy")}
		"""
		# get the actual nodes if names are passed in
		n1 = self.get_element(n1)
		n2 = self.get_element(n2)
		n1_edges = set(n1.edges)
		n2_edges = set(n2.edges)
		return n1_edges & n2_edges

	def walk_nodes(self, start, reverse=False):
		"""Provides a generator for application-defined walks.

		The start argument can be either a name or a label.

		The optional reverse argument can be used to do a reverse
		walk, ie, only walking down incoming edges.

		Usage:
			>>> g = Graph()
			>>> n1 = g.add_node()
			>>> n2 = g.add_node()
			>>> e1 = g.add_edge(n1, n2)
			>>> w = g.walk_nodes()
			>>> for adjacent_nodes in w:
			>>> 	next_node = adjacent_nodes.pop()
			>>>	w.send(next_node)
		"""
		# make sure we have a real node
		start = self.get_element(start)
		# the actual generator function, wrapped for prettitude
		def walker():
			next = start
			while next:
				if not reverse: adjacent = next.get_adjacent()
				else: adjacent = next.get_adjacent(outgoing=False, incoming=True)
				next = yield(adjacent)
		# the wrapper
		w = walker()
		candidates = next(w)
		while candidates:
			selection = (yield candidates)
			candidates = w.send(selection)
			yield

	def walk_edges(self, start):
		"""Provides a generator for application-defined walks.

		Usage is identical to walk_nodes, excepting only that it accepts,
		and yields, Edges in the place of Nodes.
		"""
		# make sure we have a real edge
		start = self.get_element(start)
		# the actual generator function
		def walker():
			next = start
			while next:
				incident = list(next.other_end(next.start).outgoing)
				next = yield(incident)
		# convenience wrapper
		w = walker()
		candidates = next(w)
		while candidates:
			selection = (yield candidates)
			candidates = w.send(selection)
			yield

	def walk_path(self, start, reverse=False):
		"""Provides a generator for application-defined walks.

		Usage is identical to walk_nodes and walk_edges, excepting that it accepts
		Nodes and yields Edges.

		Usage:
			>>> g = Graph()
			>>> g.add_node("A")
			>>> g.add_node("B")
			>>> g.add_node("C")
			>>> g.add_edge("A", "B", "AB")
			>>> g.add_edge("B", "C", "BC")
			>>> w = g.walk_path("A")
			>>> for edges in w:
			... 	selection = w.pop()
			... 	print(selection)
			... 	w.send(selection)
			Edge(name=AB)
			Edge(name=BC)
		"""
		# make sure we have a real node
		start = self.get_element(start)
		def walker():
			next = start
			while next:
				candidates = list(next.outgoing)
				next = yield(candidates)
		# convenience wrapper
		w = walker()
		previous = start
		candidates = next(w)
		while candidates:
			selection = (yield candidates).other_end(previous)
			previous = selection
			candidates = w.send(selection)
			yield

	def heuristic_walk(self, start, selector, reverse=False):
		"""Traverses the graph using selector as a selection filter on the adjacent nodes.

		The optional reverse argument allows you to do a reverse walk, ie, only finding
		adjacencies according to incoming edges rather than outgoing edges.

		Usage:
			>>> g = Graph()
			>>> g.add_node("A")
			>>> g.add_node("B")
			>>> g.add_edge("A", "B", "AB")
			>>> def selector(adjacent_nodes):
			...	return adjacent_nodes.pop()
			...
			>>> for node in g.heuristic_walk("A", selector):
			... 	print(node.name)
			B
		"""
		w = self.walk_nodes(start, reverse=reverse)
		for candidates in w:
			selection = selector(candidates)
			w.send(selection)
			yield selection

	def heuristic_traversal(self, root, selector):
		"""Traverses the graph using selector as a selection filter on the unvisited nodes.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node("A"), g.add_node("B")
			>>> e = g.add_edge(n1, n2)
			>>> for node in g.heuristic_traversal(n1, lambda s: s.pop()):
			>>> 	print(node)
			Node(name="A")
			Node(name="B")
		"""
		# handle the its-a-name case
		root = self.get_element(root)
		# stores nodes that are known to the algorithm but not yet visited
		discovered = []
		visited = set()
		discovered.append(root)
		# while there are unprocessed nodes
		while discovered:
			# select the next one
			next = selector(discovered)
			yield next
			# visit it
			visited.add(next)
			# get the adjacent nodes
			adjacent = set(next.get_adjacent())
			# filter it against those we've already visited
			not_yet_visited = adjacent - visited
			# make sure we're not double-adding
			for node in not_yet_visited:
				if node not in discovered:
					discovered.append(node)

	def heuristic_edge_traversal(self, root, selector):
		"""Traverses the graph using selector as a selection filter on the unvisited edges.

		Usage is otherwise identical to heuristic_traversal.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node("A"), g.add_node("B")
			>>> e = g.add_edge(n1, n2, name='ab')
			>>> for edge in g.heuristic_traversal(n1, lambda s: s.pop()):
			>>> 	print(edge)
			Edge(name='ab')
		"""
		# handle the its-a-name case
		root = self.get_element(root)
		# stores edges that are known to the algorithm but not yet visited
		discovered = [edge for edge in root.outgoing]
		visited = set()
		# while there are unprocessed edges
		while discovered:
			# select the next one
			next = selector(discovered)
			yield next
			# visit it
			visited.add(next)
			# get the incident edges
			incident = set([edge for edge in next.start.edges])
			incident |= set([edge for edge in next.end.edges])
			# filter it against those we've already visited
			not_yet_visited = incident - visited
			# make sure we're not double-adding
			for edge in not_yet_visited:
				if edge not in discovered:
					discovered.append(edge)

	def depth_first_traversal(self, root):
		"""Traverses the graph by visiting a node, then a child of that node, and so on.

		Usage:
			>>> g = Graph()
			>>> a, b = g.add_node("A"), g.add_node("B")
			>>> c, d = g.add_node("C"), g.add_node("D")
			>>> e1, e2 = g.add_edge(a, b), g.add_edge(a, c)
			>>> e3, e4 = g.add_edge(b, d), g.add_edge(c, d)
			>>> for node in g.depth_first_traversal(a):
			>>> 	print(node)
			Node(name="A")
			Node(name="B")
			Node(name="D")
			Node(name="C")
		"""
		for node in self.heuristic_traversal(root, lambda s: s.pop()):
			yield node

	def depth_first_edge_traversal(self, root):
		"""Traverses the graph by visiting an edge, then all descendant incident edges.

		Usage is identical to its node-centric kin.
		"""
		for edge in self.heuristic_edge_traversal(root, lambda s: s.pop()):
			yield edge

	def breadth_first_traversal(self, root):
		"""Traverses the graph by visiting a node, then each of its children, then their children.

		Usage:
			>>> g = Graph()
			>>> a, b = g.add_node("A"), g.add_node("B")
			>>> c, d = g.add_node("C"), g.add_node("D")
			>>> e1, e2 = g.add_edge(a, b), g.add_edge(a, c)
			>>> e3, e4 = g.add_edge(b, d), g.add_edge(c, d)
			>>> for node in g.breadth_first_traversal(a):
			>>> 	print(node)
			Node(name="A")
			Node(name="B")
			Node(name="C")
			Node(name="D")
		"""
		for node in self.heuristic_traversal(root, lambda s: s.pop(0)):
			yield node

	def breadth_first_edge_traversal(self, root):
		"""Traverses the graph by visiting an edge, then all adjacent incident edges.

		Usage is identical to its node-centric kin.
		"""
		for edge in self.heuristic_edge_traversal(root, lambda s: s.pop(0)):
			yield edge

	def topological_traversal(self):
		"""Traverses the graph, yielding nodes in topological order.

		This is useful in cases like a dependency graph, where it
		is desirable to get all of the nodes that depend on others
		last.

		This code is lightly modified from bearophile's pygraph
		project, and like his, simply fails to return all the nodes
		if it encounters a cycle.

		Usage:
			>>> g = Graph(edges={('a','b'),('a','c'),('b','c')})
			>>> for node in g.topological_traversal():
			... 	print(node)
			Node(name=a)
			Node(name=b)
			Node(name=c)
		"""
		# build a dictionary mapping nodes to their incoming degree
		nodes_to_degrees = {}
		for n in self.nodes:
		    nodes_to_degrees[n] = len(n.incoming)

		# get a queue of source nodes, ie, those with 0 incoming edges.
		queue = deque(n for n, degree in nodes_to_degrees.items() if not degree)
		while queue:
			n = queue.popleft()
			yield n
			# get the nodes which n is outgoing adjacent to
			for destination in n.get_adjacent(outgoing=True, incoming=False):
				nodes_to_degrees[destination] -= 1
				# if the destination is now a source
				if not nodes_to_degrees[destination]:
				    queue.append(destination)

	def level_traversal(self, root):
		"""Traverses the graph, yielding nodes by level.

		This is useful for building level graphs and other network
		structures.

		Usage:
			>>> g = Graph(edges={('a', 'b'),('a','c'),('b','c'),('b','d')})
			>>> for level in g.level_traversal():
			... 	print(level)
			{Node('a')}
			{Node('b'), Node('c')}
			{Node('d')}
		"""
		paths = self.get_shortest_paths(root)
		levels = []
		for end, path in paths.items():
			while path.weight >= len(levels):
				levels.append(set())
			levels[path.weight].add(end)
		for i in levels: yield i

	def get_connected_components(self):
		"""Gets all the connected components from the graph.

		Returns a list of sets of vertices.

		Usage:
			>>> g = Graph()
			>>> n1 = g.add_node(group=1)
			>>> n2 = g.add_node(group=1)
			>>> n3 = g.add_node(group=2)
			>>> e1 = g.add_edge(n1, n2)
			>>> g.get_connected_components()
			[{Node(group=1), Node(group=1)}, {Node(group=2)}]
		"""
		# set of all connected components
		connected = []
		# iterate over the nodes
		for node in self.nodes:
			# get all the nodes that are reachable from this node
			discovered = set(self.depth_first_traversal(node))
			add_this = True
			for component in connected:
				# if the newly discovered component is part of
				# an existing component
				if discovered.issubset(component):
					# don't add it
					add_this = False
					break
				# if the existing component is a part of the
				# newly discovered component
				elif discovered.issuperset(component):
					# don't add it
					add_this = False
					# but replace the old component with
					# the new one
					connected.remove(component)
					connected.append(discovered)
					continue
			# if this component was not a part of an existing
			# component or vice versa...
			if add_this:
				# add it to the components list
				connected.append(discovered)
		return connected

	def get_strongly_connected(self):
		"""Returns a list of all strongly connected components.

		Each SCC is expressed as a set of vertices.

		Usage is identical to get_connected_components.
		"""
		# list of all SCCs
		strongly_connected_components = []
		# iterate over all connected components
		for c in self.get_connected_components():
			# get an arbitrary node
			arbitrary = c.pop()
			# get all the nodes visitable from there
			visited = [node for node in self.depth_first_traversal(arbitrary)]
			# reverse the direction of the edges in the graph
			self.transpose()
			# while there are still elements which aren't reachable
			while visited:
				current_component = set()
				for node in self.depth_first_traversal(visited.pop(0)):
					current_component.add(node)
					try:
						visited.remove(node)
					except:
						pass
			strongly_connected_components.append(current_component)
			self.transpose()
		return strongly_connected_components

	def get_cycles(self):
		"""Finds and returns a list of cycles in the current graph.

		Each cycle is represented as an independent graph.
		"""
		acyclic_nodes = set(self.topological_traversal())
		cyclic_nodes = (node for node in self.nodes if node not in acyclic_nodes)
		g = self.induce_subgraph(*cyclic_nodes)
		return g.get_connected_components()

	def get_path(self, start, end):
		"""Gets an arbitrary path from start to end.

		Note that it is *not* gauranteed to be the shortest such
		path.

		Raises ValueError if the requested path does not exist.

		Usage:
			>>> g = Graph()
			>>> ab = g.add_edge('a', 'b')
			>>> bc = g.add_edge('b', 'c')
			>>> cd = g.add_edge('c', 'd')
			>>> ad = g.add_edge('a', 'd')
			>>> g.get_path('a', 'd')
			... <Graph object at 0x1da73d0>
		"""
		start = self[start]
		end = self[end]
		path = []
		for edge in self.depth_first_edge_traversal(start):
			if not path: path = [edge]
			if edge in end.incoming:
				return self.edge_induce_subgraph(*(path + [edge]))
			for pos, parent in enumerate(path):
				if edge == parent:
					path = path[:pos] + [edge]
				elif parent.end == edge.start :
					path = path[:pos+1] + [edge]
				else:
					path += [edge]
		raise ValueError("No path from %s to %s found" % (start, end))

	def get_shortest_paths(self, source, get_weight=lambda e: 1, pretty=True):
		"""Finds the shortest path to all connected nodes from source.

		The optional get_weight argument should be a callable that
		accepts an edge and returns its weight.

		Returns a dictionary of node -> subgraph mappings.
		Each subgraph has an additional 'weight' attribute
		that specifies the total weight of the path.

		Usage:
			>>> g = Graph()
			>>> n1 = g.add_node("A")
			>>> n2 = g.add_node("B")
			>>> n3 = g.add_node("C")
			>>> n4 = g.add_node("D")
			>>> e1 = g.add_edge(n1, n2, weight=10)
			>>> e2 = g.add_edge(n1, n4, weight=1)
			>>> e3 = g.add_edge(n2, n3, weight=1)
			>>> e4 = g.add_edge(n3, n4, weight=1)
			>>> d = g.get_shortest_paths(n1, get_weight=lambda e: e.weight)
			>>> d[n1]
			(0, [])
			>>> d[n2]
			(10, [Edge(weight=10)])
			>>> d[n3]
			(11, [Edge(weight=10), Edge(weight=1)])
			>>> d[n4]
			(1, [Edge(weight=1)])
		"""
		# handle the its-a-name case
		source = self.get_element(source)
		# create the paths table
		paths = defaultdict(lambda: (float("inf"), []))
		paths[source] = (0, [])
		# create the minimum distance heap
		unoptomized = [(0, source)]
		# main loop
		while unoptomized:
			# pop the minimum distanced node
			distance, current = heapq.heappop(unoptomized)
			# iterate over its outgoing edges
			for edge in current.outgoing:
				# get the old path to the endpoint
				old_weight, old_path = paths[edge.other_end(current)]
				# get the weight of this path to the edge's end
				weight, path = paths[current]
				weight += get_weight(edge)
				# if the new path is better than the old path
				if weight < old_weight:
					# relax it
					paths[edge.other_end(current)] = (weight, path + [edge])
					# and put it on the heap
					heapq.heappush(unoptomized, (weight, edge.other_end(current)))
		# this preserves compatibility with the old way
		if not pretty:
			return paths
		else:
			# makes it a lot prettier
			processed_paths = {}
			# turn the lists of edges into graphs
			for endpoint, weight_and_edges in paths.items():
				weight, path = weight_and_edges
				# induce the graph on the edges
				induced_path = self.edge_induce_subgraph(*path)
				# give it a weight attribute
				induced_path.weight = weight
				# and fill the data structure
				processed_paths[endpoint] = induced_path
			return processed_paths

	def minimum_span(self, weight=lambda e: 1):
		"""Returns the minimum spanning tree/forest for a given graph.

		Returns a graph object that represents the MST/F.

		Usage:
			>>> g = Graph()
			>>> g.add_edge('a', 'b', weight=10)
			>>> g.add_edge('a', 'c', weight=10)
			>>> g.add_edge('b', 'c', weight=11)
			>>> g.minimum_span(lambda e: e.weight)
			... <graph object>

		"""
		tree = self.__class__()
		for e in sorted(list(self.edges), key=weight):
			if not ((e.start in tree) and (e.end in tree)):
				tree.add_edge(e.start.name, e.end.name, e.name, **e.data)
		return tree

	@property
	def size(self):
		"""Reports the number of edges in the graph.

		Usage:
			>>> g = Graph()
			>>> n1, n2 = g.add_node(), g.add_node()
			>>> g.size
			0
			>>> e = g.add_edge(n1, n2)
			>>> g.size
			1
		"""
		return len(self.edges)

	@property
	def order(self):
		"""Reports the number of nodes in the graph.

		Usage:
			>>> g = Graph()
			>>> g.order
			0
			>>> n = g.add_node()
			>>> g.order
			1
		"""
		return len(self.nodes)

	#########################################################################
	#			Graph Rewriting Tools				#
	#########################################################################

	def move_edge(self, edge, start=None, end=None):
		"""Moves the edge, leaving its data intact.

		Does not change a directed edge into an undirected edge.
		"""
		# get the edge if its a name
		edge = self.get_element(edge)
		if edge.is_directed:
			edge.start._outgoing.remove(edge)
			edge.end._incoming.remove(edge)
		else:
			try:	# to fix the problem with undirected loops
				edge.start._bidirectional.remove(edge)
				edge.end._bidirectional.remove(edge)
			except:
				pass
		edge._start = start or edge.start
		edge._end = end or edge.end
		if edge.is_directed:
			edge.start._outgoing.append(edge)
			edge.end._incoming.append(edge)
		else:
			edge.start._bidirectional.append(edge)
			# fix the problem with undirected loops
			if start is not end:
				edge.end._bidirectional.append(edge)
		return edge

	def contract_edge(self, edge, node_data):
		"""Contracts the given edge, merging its endpoints.

		node_data should be a callable that returns a dictionary.
		That dictionary will be used to initialize the new node.

		It returns the node so created.

		There are two caveats about using this:

		1) The name passed back by node_data, if present, must
		   still be unique- and the old nodes can't be deleted
		   until after the new one is added.

		2) Note that if multiple edges exist between the two nodes,
		   this will still contract them!
		"""
		# get the edge if its a name
		edge = self.get_element(edge)
		# check to make sure that the given edge is the only edge between
		# it endpoints
		start = edge.start
		end = edge.end
		new_node = self.add_node(**node_data(start, end))
		# delete the given edge
		self.remove_edge(edge)
		# move all incoming edges
		for edge in start.incoming + end.incoming:
			self.move_edge(edge, end=new_node)
		# move all outgoing edges
		for edge in start.outgoing + end.outgoing:
			self.move_edge(edge, start=new_node)
		# delete the existing endpoints
		# remember, this may be a loop, so you may
		# only be able to remove one.
		try:
			self.remove_node(start)
			self.remove_node(end)
		except KeyError:
			pass
		return new_node

	def transpose(self):
		"""Reverses the directions on all edges in the current graph"""
		for e in self.edges:
			self.move_edge(e, start=e.end, end=e.start)

	def induce_subgraph(self, *nodes):
		"""Returns a new graph composed of only the specified nodes and their mutual edges.

		Usage:

		Set up your graph:

			>>> enterprise = Graph()
			>>> kirk = enterprise.add_node("kirk")
			>>> spock = enterprise.add_node("spock")
			>>> bones = enterprise.add_node("mccoy")
			>>> enterprise.add_edge(kirk, spock)
			>>> enterprise.add_edge(kirk, bones)

		As you can see, it has 3 nodes and two edges:

			>>> enterprise.order
			3
			>>> enterprise.size
			2

		Now we induce a subgraph that includes spock and bones but
		not the captain:

			>>> new_mission = enterprise.induce_subgraph(spock, bones)

		And can see that it has two nodes- spock and bones- but no edges:

			>>> new_mission.order
			2
			>>> new_mission.size
			0
		"""
		g = self.__class__()
		for node in nodes:
			node = self.get_element(node)
			name = node.name
			data = node.data
			n = g.add_node(name, **data)
		for edge in self.edges:
			if edge.start in g:
				if edge.end in g:
					name = edge.name
					start = edge.start.name
					end = edge.end.name
					is_directed = edge.is_directed
					data = edge.data
					g.add_edge(start, end, name, **data)
		return g

	def edge_induce_subgraph(self, *edges):
		"""Similar to induce_subgraph but accepting edges rather than nodes."""
		# create the new graph
		g = self.__class__()
		for edge in edges:
			edge = self.get_element(edge)
			# and add them if they don't already exist
			if edge.start not in g:
				g.add_node(edge.start.name, **edge.start.data)
			if edge.end not in g:
				g.add_node(edge.end.name, **edge.end.data)
		# iterate over the provided edges
		for edge in edges:
			# and add them, translating nodes as we go
			g.add_edge(edge.start.name, edge.end.name, edge.name, **edge.data)
		return g

	#########################################################################
	#			Graph Comparison Tools				#
	#########################################################################

	def union(self, other):
		"""Returns a new graph with all nodes and edges in either of its parents.

		Usage:
			>>> g1 = Graph()
			>>> g2 = Graph()
			>>> a = g1.add_node(1)
			>>> b = g1.add_node(3)
			>>> c = g1.add_node(5)
			>>> ab = g1.add_edge(a, b, 2)
			>>> bc = g1.add_edge(b, c, 4)
			>>> d = g2.add_node(3)
			>>> e = g2.add_node(5)
			>>> f = g2.add_node(7)
			>>> de = g2.add_edge(d, e, 4)
			>>> ef = g2.add_edge(e, f, 6)
			>>> g3 = g1 | g2
			>>> [node.name for node in g3.nodes]
			[1, 3, 5, 7]
			>>> [edge.name for edge in g3.edges]
			[2, 4, 6]
		"""
		# create the graph
		g = self.__class__()
		# add our nodes
		for node in chain(self.nodes, other.nodes):
			g.add_node(node.name, **node.data)
		# and for edges
		for edge in chain(self.edges, other.edges):
			g.add_edge(edge.start.name, edge.end.name, edge.name, edge.is_directed, **edge.data)
		return g

	def intersection(self, other):
		"""Returns a graph containing only the nodes and edges in both of its parents.

		Note that both endpoints must exist in the new graph for an edge to exist.

		Usage:
			>>> g1 = Graph()
			>>> g2 = Graph()
			>>> a = g1.add_node(1)
			>>> b = g1.add_node(3)
			>>> c = g1.add_node(5)
			>>> ab = g1.add_edge(a, b, 2)
			>>> bc = g1.add_edge(b, c, 4)
			>>> d = g2.add_node(3)
			>>> e = g2.add_node(5)
			>>> f = g2.add_node(7)
			>>> de = g2.add_edge(d, e, 4)
			>>> ef = g2.add_edge(e, f, 6)
			>>> g3 = g1 & g2
			>>> [node.name for node in g3.nodes]
			[3, 5]
			>>> [edge.name for edge in g3.edges]
			[4]
		"""
		# create the graph
		g = self.__class__()
		# iterate through our nodes
		for node in self.nodes:
			if node in other:
				name = node.name
				data = node.data
				g.add_node(name, **data)
		# and theirs
		for node in other.nodes:
			if node in self:
				name = node.name
				data = node.data
				g.add_node(name, **data)
		# ...and our edges...
		for edge in self.edges:
			if edge in other:
				name = edge.name
				start = edge.start
				end = edge.end
				if start in g and end in g:
					is_directed = edge.is_directed
					data = edge.data
					g.add_edge(start.name, end.name, name, is_directed, **data)
		# ...and theirs
		for edge in other.edges:
			if edge in self:
				name = edge.name
				start = edge.start
				end = edge.end
				if start in g and end in g:
					is_directed = edge.is_directed
					data = edge.data
					g.add_edge(start.name, end.name, name, is_directed, **data)
		return g

	def difference(self, other):
		"""Return a graph composed of the nodes and edges not in the other.

		Usage:
			>>> g1 = Graph()
			>>> g2 = Graph()
			>>> a = g1.add_node(1)
			>>> b = g1.add_node(3)
			>>> c = g1.add_node(5)
			>>> ab = g1.add_edge(a, b, 2)
			>>> bc = g1.add_edge(b, c, 4)
			>>> d = g2.add_node(3)
			>>> e = g2.add_node(5)
			>>> f = g2.add_node(7)
			>>> de = g2.add_edge(d, e, 4)
			>>> ef = g2.add_edge(e, f, 6)
			>>> g3 = g1 & g2
			>>> [node.name for node in g3.nodes]
			[1]
			>>> [edge.name for edge in g3.edges]
			[]
		"""
		# create the graph
		g = self.__class__()
		# create all the equivalent nodes
		for node in self.nodes:
			if node not in other:
				g.add_node(node.name, **node.data)
		# create all the equivalent edges
		for edge in self.edges:
			if edge not in other:
				if edge.start in g and edge.end in g:
					g.add_edge(edge.start, edge.end, edge.name, **edge.data)
		return g

	def contains(self, other):
		"""Tests to see if other is a subgraph of this graph.

		Comparison is based on names, and compares both nodes and edges.
		"""
		if set(self.nodes).issuperset(other.nodes):
			if set(self.edges).issuperset(other.edges):
				return True
		return False
